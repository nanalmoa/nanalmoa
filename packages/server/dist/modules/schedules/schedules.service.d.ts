import { Repository } from 'typeorm';
import { Schedule } from '../../entities/schedule.entity';
import { Category } from '@/entities/category.entity';
import { CreateScheduleDto } from './dto/create-schedule.dto';
import { UpdateScheduleDto } from './dto/update-schedule.dto';
import { ResponseScheduleDto } from './dto/response-schedule.dto';
import { WeekQueryDto } from './dto/week-query-schedule.dto';
import { ConfigService } from '@nestjs/config';
import { VoiceTranscriptionService } from './voice-transcription.service';
import { UsersService } from '../users/users.service';
import { GroupService } from '../group/group.service';
import { GroupSchedule } from '@/entities/group-schedule.entity';
export declare class SchedulesService {
    private schedulesRepository;
    private categoryRepository;
    private readonly configService;
    private readonly voiceTranscriptionService;
    private readonly usersService;
    private groupScheduleRepository;
    private groupService;
    private openai;
    private readonly logger;
    constructor(schedulesRepository: Repository<Schedule>, categoryRepository: Repository<Category>, configService: ConfigService, voiceTranscriptionService: VoiceTranscriptionService, usersService: UsersService, groupScheduleRepository: Repository<GroupSchedule>, groupService: GroupService);
    findAllByUserUuid(userUuid: string): Promise<ResponseScheduleDto[]>;
    getSchedulesInRange(userUuid: string, startDate: Date, endDate: Date): Promise<ResponseScheduleDto[]>;
    private findSharedGroupSchedules;
    private findSharedGroupSchedulesByScheduleId;
    findByMonth(userUuid: string, year: number, month: number): Promise<ResponseScheduleDto[]>;
    findByWeek(userUuid: string, date: string): Promise<ResponseScheduleDto[]>;
    findByDate(dateQuery: WeekQueryDto): Promise<ResponseScheduleDto[]>;
    findByYear(userUuid: string, year: number): Promise<ResponseScheduleDto[]>;
    findOne(id: number): Promise<ResponseScheduleDto>;
    createSchedule(userUuid: string, createScheduleDto: CreateScheduleDto): Promise<ResponseScheduleDto>;
    private validateRecurringOptions;
    updateSchedule(userUuid: string, scheduleId: number, updateScheduleDto: UpdateScheduleDto, instanceDate: Date, updateType?: 'single' | 'future'): Promise<ResponseScheduleDto>;
    private updateNonRecurringSchedule;
    private updateSingleInstance;
    private updateFutureInstances;
    deleteSchedule(userUuid: string, scheduleId: number, instanceDate: string, deleteType?: 'single' | 'future'): Promise<void>;
    private removeUserFromFutureGroupSchedules;
    private deleteFutureInstances;
    private deleteSingleInstance;
    private findRecurringSchedules;
    private findRegularSchedulesInRange;
    private expandRecurringSchedules;
    private isOccurrenceDate;
    private getNextOccurrenceDate;
    private createOccurrence;
    private adjustDateForAllDay;
    private getCategoryById;
    private validateUser;
    private convertToResponseDto;
    parseGptResponse(response: string): any[];
    private processWithGpt;
    processWithGptOCR(OCRResult: string): Promise<any>;
    private formatDateToYYYYMMDDHHMMSS;
    private convertGptResponseToCreateScheduleDto;
    transcribeRTZRAndFetchResultWithGpt(file: Express.Multer.File, currentDateTime: string, userUuid: string): Promise<CreateScheduleDto[]>;
    transcribeWhisperAndFetchResultWithGpt(file: Express.Multer.File, currentDateTime: string, userUuid: string): Promise<CreateScheduleDto[]>;
}
